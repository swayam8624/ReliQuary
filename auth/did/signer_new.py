# auth/did/signer.py

import os
import sqlite3
from typing import Optional, Dict, Any
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from webauthn.helpers import base64url_to_bytes

class DIDSignature:
    """Represents a DID signature"""
    def __init__(self, signature: bytes, did: str):
        self.signature = signature
        self.did = did

class DIDSigner:
    """Signs data using DID-linked keys"""
    
    def __init__(self):
        pass
    
    def sign(self, did: str, message: bytes) -> Optional[DIDSignature]:
        """
        Signs a message with a DID-linked key.
        In a real system, this would happen on the client side using the authenticator.
        For this test, we generate a dummy signature.
        """
        # This is not a real signature, but allows us to test the verification process flow.
        # A real signature would be generated by the WebAuthn API's get() method.
        print("Note: Generating a dummy signature for simulation purposes.")
        signature = os.urandom(64)
        return DIDSignature(signature, did)
    
    def verify(self, did_doc: Dict[str, Any], message: bytes, signature: bytes) -> bool:
        """
        Verifies a signature against the public key found in a DID Document.
        """
        try:
            verification_method = did_doc["verificationMethod"][0]
            if verification_method["type"] != "JsonWebKey2020":
                return False

            jwk = verification_method["publicKeyJwk"]
            
            # Reconstruct the public key from the JWK values
            x = int.from_bytes(base64url_to_bytes(jwk["x"]), "big")
            y = int.from_bytes(base64url_to_bytes(jwk["y"]), "big")
            public_key = ec.EllipticCurvePublicNumbers(x, y, ec.SECP256R1()).public_key()
            
            print("âœ… Public key successfully reconstructed from DID Document.")

            # In a real system, you would verify the real signature like this:
            # try:
            #     public_key.verify(signature, message, ec.ECDSA(hashes.SHA256()))
            #     return True
            # except InvalidSignature:
            #     return False
            
            # Since we have a dummy signature, we'll assume it's valid for this conceptual test.
            # This placeholder confirms the key can be loaded and the process is sound.
            print("Note: The actual cryptographic verification is being simulated.")
            return True
        except Exception as e:
            print(f"Error during signature verification: {e}")
            return False

def get_absolute_db_path():
    """Calculates the absolute path to the database to ensure it's always found."""
    try:
        # This works when running as a .py file
        script_dir = os.path.dirname(os.path.realpath(__file__))
        project_root = os.path.abspath(os.path.join(script_dir, '..', '..'))
    except NameError:
        # This is a fallback for interactive environments like Jupyter.
        project_root = os.getcwd()
    
    return os.path.join(project_root, 'auth', 'webauthn', 'keys.db')

# --- Configuration ---
DB_PATH = get_absolute_db_path()

def get_public_key_from_db(username: str) -> bytes:
    """Helper to retrieve the public key blob from the database."""
    if not os.path.exists(DB_PATH):
        raise FileNotFoundError(f"Database file not found at the expected path: {DB_PATH}")

    with sqlite3.connect(f"file:{DB_PATH}?mode=ro", uri=True) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT public_key FROM credentials WHERE username=?", (username,))
        result = cursor.fetchone()
        if result:
            return result[0]
    return None